// Generated by ChatGPT

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Sockets.Kcp;
using System.Xml;

namespace OuterCode
{
    public class TraceList<T> : IList<T>
    {
        private readonly List<T> _list = new List<T>();
        private readonly UniqueIDManager _uniqueID = new(nameof(TraceList<T>));
        private readonly SingleThreadAssert _stalock = new(nameof(TraceList<T>));

        public int Count => _list.Count;

        public bool IsReadOnly => ((ICollection<T>)_list).IsReadOnly;

        public T this[int index]
        {
            get
            {
                _stalock.Enter();
                try
                {
                    return _list[index];
                }
                finally
                {
                    _stalock.Exit();
                }
            }
            set
            {
                _stalock.Enter();
                try
                {
                    Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Setting value at index {index} to {value}");
                    _list[index] = value;
                }
                finally
                {
                    _stalock.Exit();
                }
            }
        }

        public void Add(T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Adding item {item}");
                _list.Add(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void Clear()
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] Clearing list");
                _list.Clear();
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public bool Contains(T item)
        {
            _stalock.Enter();
            try
            {
                return _list.Contains(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            _stalock.Enter();
            try
            {
                _list.CopyTo(array, arrayIndex);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _list.GetEnumerator();
        }

        public int IndexOf(T item)
        {
            _stalock.Enter();
            try
            {
                return _list.IndexOf(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void Insert(int index, T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Inserting item {item} at index {index}");
                _list.Insert(index, item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public bool Remove(T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing item {item}");
                return _list.Remove(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void RemoveAt(int index)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing item {_list[index]} at index {index}");
                _list.RemoveAt(index);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void RemoveRange(int index, int count)
        {
            _stalock.Enter();
            try
            {
                var items = _list.GetRange(index, count);
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing {count} items starting at index {index}: [ {string.Join("; ", items)} ]");
                _list.RemoveRange(index, count);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return ((IEnumerable)_list).GetEnumerator();
        }

        private string Invoker()
        {
            StackTrace stackTrace = new StackTrace();
            StackFrame frame = stackTrace.GetFrame(2);
            return frame.ToString() ?? "-----Invoker Not found-----";
        }
    }

    public class SegmentTraceList<T> : IList<T> where T : IKcpSegment
    {
        private readonly List<T> _list = new List<T>();
        private readonly UniqueIDManager _uniqueID = new(nameof(SegmentTraceList<T>));
        private readonly SingleThreadAssert _stalock = new(nameof(SegmentTraceList<T>));

        public int Count => _list.Count;

        public bool IsReadOnly => ((ICollection<T>)_list).IsReadOnly;

        public T this[int index]
        {
            get
            {
                _stalock.Enter();
                try
                {
                    return _list[index];
                }
                finally
                {
                    _stalock.Exit();
                }
            }
            set
            {
                _stalock.Enter();
                try
                {
                    Console.WriteLine($"[{nameof(SegmentTraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Setting value at index {index} to {value.ToLogString(false)}");
                    _list[index] = value;
                }
                finally
                {
                    _stalock.Exit();
                }
            }
        }

        public void Add(T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Adding item {item.ToLogString(false)}");
                _list.Add(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void Clear()
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(SegmentTraceList<T>)}_{_uniqueID.ID}] Clearing list");
                _list.Clear();
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public bool Contains(T item)
        {
            _stalock.Enter();
            try
            {
                return _list.Contains(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void CopyTo(T[] array, int arrayIndex)
        {
            _stalock.Enter();
            try
            {
                _list.CopyTo(array, arrayIndex);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _list.GetEnumerator();
        }

        public int IndexOf(T item)
        {
            _stalock.Enter();
            try
            {
                return _list.IndexOf(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void Insert(int index, T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(SegmentTraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Inserting item {item.ToLogString(false)} at index {index}");
                _list.Insert(index, item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public bool Remove(T item)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing item {item.ToLogString(false)}");
                return _list.Remove(item);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void RemoveAt(int index)
        {
            _stalock.Enter();
            try
            {
                Console.WriteLine($"[{nameof(SegmentTraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing item {_list[index].ToLogString(false)} at index {index}");
                _list.RemoveAt(index);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        public void RemoveRange(int index, int count)
        {
            _stalock.Enter();
            try
            {
                var items = _list.GetRange(index, count);
                Console.WriteLine($"[{nameof(TraceList<T>)}_{_uniqueID.ID}] TraceList invoker: {Invoker()}; Count: {_list.Count};  Removing {count} items starting at index {index}: [ {string.Join("; ", items)} ]");
                _list.RemoveRange(index, count);
            }
            finally
            {
                _stalock.Exit();
            }
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _list.GetEnumerator();
        }

        private string Invoker()
        {
            StackTrace stackTrace = new StackTrace();
            StackFrame frame = stackTrace.GetFrame(2);
            return frame.ToString() ?? "-----Invoker Not found-----";
        }
    }
}